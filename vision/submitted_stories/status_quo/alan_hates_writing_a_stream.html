<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Alan hates writing a Stream - wg-async</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">wg-async</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/wg-async" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/wg-async/edit/master/src/vision/submitted_stories/status_quo/alan_hates_writing_a_stream.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-status-quo-stories-alan-hates-writing-a-stream"><a class="header" href="#-status-quo-stories-alan-hates-writing-a-stream">ðŸ˜± Status quo stories: Alan hates writing a <code>Stream</code></a></h1>
<h2 id="-warning-draft-status-"><a class="header" href="#-warning-draft-status-">ðŸš§ Warning: Draft status ðŸš§</a></h2>
<p>This is a draft "status quo" story submitted as part of the brainstorming period. It is derived from real-life experiences of actual Rust users and is meant to reflect some of the challenges that Async Rust programmers face today.</p>
<p>If you would like to expand on this story, or adjust the answers to the FAQ, feel free to open a PR making edits (but keep in mind that, as they reflect peoples' experiences, status quo stories <a href="../../how_to_vision/comment.html#comment-to-understand-or-improve-not-to-negate-or-dissuade">cannot be wrong</a>, only inaccurate). Alternatively, you may wish to <a href="../status_quo.html">add your own status quo story</a>!</p>
<h2 id="the-story"><a class="header" href="#the-story">The story</a></h2>
<p><a href="../../characters/alan.html">Alan</a> is used to writing web server applications using async sockets, but wants to try Rust to get that signature vroom vroom.</p>
<p>After a couple weeks learning Rust basics, Alan quickly understands <code>async</code> and <code>await</code>, and therefore has several routes built for his application that await a few things and then construct an HTTP response and send a buffered body. To build the buffered response bodies, Alan was reading a file, and then appending a signature, and putting that all into a single buffer of bytes.</p>
<p>Eventually, Alan realizes that some responses have enormous bodies, and would like to stream them instead of buffering them fully in memory. He's <em>used</em> the <code>Stream</code> trait before. Using it was very natural, and followed a similar pattern to regular <code>async</code>/<code>await</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(chunk) = body.next().await? {
    file.write_all(&amp;chunk).await?;
}
<span class="boring">}</span></code></pre></pre>
<p>However, <em>implementing</em> <code>Stream</code> turns out to be rather different. With a quick search, he learned the simple way to turn a <code>File</code> into a <code>Stream</code> with <code>ReaderStream</code>, but the signing part was much harder.</p>
<h3 id="imperatively-wrong"><a class="header" href="#imperatively-wrong">Imperatively Wrong</a></h3>
<p>Alan first hoped he could simply write signing stream imperatively, reusing his new knowledge of <code>async</code> and <code>await</code>, and assuming it'd be similar to JavaScript:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async* fn sign(file: ReaderStream) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    let mut sig = Signature::new();

    while let Some(chunk) = file.next().await? {
        sig.push(&amp;chunk);
        yield Ok(chunk)
    }

    yield Ok(sig.digest().await)
}
<span class="boring">}</span></code></pre></pre>
<p>Unfortunately, that doesn't work. The compiler first complains about the <code>async* fn</code> syntax:</p>
<pre><code class="language-notrust">error: expected item, found keyword `async`
  --&gt; src/lib.rs:21:1
   |
21 | async* fn sign(file: ReaderStream) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
   | ^^^^^ expected item
</code></pre>
<p>Less hopeful, Alan tries just deleting the asterisk:</p>
<pre><code class="language-notrust">error[E0658]: yield syntax is experimental
  --&gt; src/lib.rs:27:9
   |
27 |         yield Ok(chunk)
   |         ^^^^^^^^^^^^^^^
   |
   = note: see issue #43122 &lt;https://github.com/rust-lang/rust/issues/43122&gt; for more information
</code></pre>
<p>After reading about how yield is experimental, and giving up reading the 100+ comments in the <a href="https://github.com/rust-lang/rust/issues/43122">linked issue</a>, Alan figures he's just got to implement <code>Stream</code> manually.</p>
<h3 id="implementing-stream"><a class="header" href="#implementing-stream">Implementing <code>Stream</code></a></h3>
<p>Implementing a <code>Stream</code> means writing async code in a way that doesn't <em>feel</em> like the <code>async fn</code> that Alan has written so far. He needs to write a <code>poll</code> function and it has a lot of unfamiliar concepts:</p>
<ul>
<li><code>Pin</code></li>
<li>State machines</li>
<li><code>Wakers</code></li>
</ul>
<p>Unsure of what the final code will look like, he starts with:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SigningFile;

impl Stream for SigningFile {
    type Item = Result&lt;Vec&lt;u8&gt;, Error&gt;;
    
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context)
        -&gt; Poll&lt;Self::Item&gt;
    {
 
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pin-scream"><a class="header" href="#pin-scream">Pin :scream:</a></h3>
<p>First, he notices <code>Pin</code>. Alan wonders, "Why does <code>self</code> have bounds? I've only ever seen <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code> before". Curious, he reads the <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>std::pin</code></a> page, and a bunch of jargon about pinning data in memory. He also reads that this is useful to guarantee that an object cannot move, and he wonders why he cares about that. The only example on the page explains how to write a <a href="https://doc.rust-lang.org/std/pin/index.html#example-self-referential-struct">"self-referential struct"</a>, but notices it needs <code>unsafe</code> code, and that triggers an internal alarm in Alan: "I thought Rust was safe..."</p>
<p>After asking <a href="../../characters/barbara.html">Barbara</a>, Alan realizes that the types he's depending on are <code>Unpin</code>, and so he doesn't need to worry about the unsafe stuff. It's just a more-annoying pointer type.</p>
<h3 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h3>
<p>With <code>Pin</code> hopefully ignored, Alan next notices that in the imperative style he wanted originally, he didn't need to explicitly keep track of state. The state was simply the imperative order of the function. But in a <code>poll</code> function, the state isn't saved by the compiler. Alan finds blog posts about the dark ages of Futures 0.1, when it was more common for manual <code>Future</code>s to be written with a "state machine".</p>
<p>He thinks about his stream's states, and settles on the following structure:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SigningFile {
    state: State,
    file: ReaderStream,
    sig: Signature,
}

enum State {
    File,
    Sign,
}
<span class="boring">}</span></code></pre></pre>
<p>It turns out it was more complicated than Alan thought (the author made this same mistake). The <code>digest</code> method of <code>Signature</code> is <code>async</code>, <em>and</em> it consumes the signature, so the state machine needs to be adjusted. The signature needs to be able to be moved out, and it needs to be able to store a future from an <code>async fn</code>. Trying to figure out how to represent that in the type system was difficult. He considered adding a generic <code>T: Future</code> to the <code>State</code> enum, but then wasn't sure what to set that generic to. Then, he tries just writing <code>Signing(impl Future)</code> as a state variant, but that triggers a compiler error that <code>impl Trait</code> isn't allowed outside of function return types. Patient <a href="../../characters/barbara.html">Barbara</a> helped again, so that Alan learns to just store a <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>, wondering if the <code>Pin</code> there is important.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SigningFile {
    state: State,
}

enum State {
    File(ReaderStream, Signature),
    Signing(Pin&lt;Box&lt;dyn Future&lt;Output = Vec&lt;u8&gt;&gt;&gt;&gt;),
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>Now he tries to write the <code>poll_next</code> method, checking readiness of individual steps (thankfully, Alan remembers <code>ready!</code> from the futures 0.1 blog posts he read) and proceeding to the next state, while grumbling away the weird <code>Pin</code> noise:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match self.state {
    State::File(ref mut file, ref mut sig) =&gt; {
        match ready!(Pin::new(file).poll_next(cx)) {
            Some(result) =&gt; {
                let chunk = result?;
                sig.push(&amp;chunk);
                Poll::Ready(Some(Ok(chunk)))
            },
            None =&gt; {
                let sig = match std::mem::replace(&amp;mut self.state, State::Done) {
                    State::File(_, sig) =&gt; sig,
                    _ =&gt; unreachable!(),
                };
                self.state = State::Signing(Box::pin(sig.digest()));
                Poll::Pending
            }
        }
    },
    State::Signing(ref mut sig) =&gt; {
        let last_chunk = ready!(sig.as_mut().poll(cx));
        self.state = State::Done;
        Poll::Ready(Some(Ok(last_chunk)))
    }
    State::Done =&gt; Poll::Ready(None),
}
<span class="boring">}</span></code></pre></pre>
<p>Oh well, at least it <em>works</em>, right?</p>
<h3 id="wakers"><a class="header" href="#wakers">Wakers</a></h3>
<p>So far, Alan hasn't paid too much attention to <code>Context</code> and <code>Poll</code>. It's been fine to simply pass them along untouched. There's a confusing bug in his state machine. Let's look more closely:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// zooming in!
match ready!(Pin::new(file).poll_next(cx)) {
    Some(result) =&gt; {
        let chunk = result?;
        sig.push(&amp;chunk);
        return Poll::Ready(Some(Ok(val));
    },
    None =&gt; {
        self.set_state_to_signing();
        // oops!
        return Poll::Pending;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In one of the branches, the state is changed, and <code>Poll::Pending</code> is returned. Alan assumes that the task will be polled again with the new state. But, since the file was done (and has returned <code>Poll::Ready</code>), there was actually no waker registered to wake the task again. So his stream just hangs forever.</p>
<p>The compiler doesn't help at all, and he re-reads his code multiple times, but because of this easy-to-misunderstand logic error, Alan eventually has to ask for help in a chat room. After a half hour of explaining all sorts of details, a kind person points out he either needs to register a waker, or perhaps use a loop.</p>
<p>All too often, since we don't want to duplicate code in multiple branches, the solution for Alan is to add an odd <code>loop</code> around the whole thing, so that the next match branch uses the <code>Context</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    match self.state {
        State::File(ref mut file, ref mut sig) =&gt; {
            match ready!(Pin::new(file).poll_next(cx)) {
                Some(result) =&gt; {
                    let chunk = result?;
                    sig.push(&amp;chunk);
                    return Poll::Ready(Some(Ok(chunk)))
                },
                None =&gt; {
                    let sig = match std::mem::replace(&amp;mut self.state, State::Done) {
                        State::File(_, sig) =&gt; sig,
                        _ =&gt; unreachable!(),
                    };
                    self.state = State::Signing(Box::pin(sig.digest()));
                    // loop again, to catch the `State::Signing` branch
                }
            }
        },
        State::Signing(ref mut sig) =&gt; {
            let last_chunk = ready!(sig.as_mut().poll(cx));
            self.state = State::Done;
            return Poll::Ready(Some(Ok(last_chunk)))
        }
        State::Done =&gt; return Poll::Ready(None),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gives-up"><a class="header" href="#gives-up">Gives Up</a></h3>
<p>A little later, Alan needs to add some response body transforming to some routes, to add some app-specific framing. Upon realizing he needs to implement another <code>Stream</code> in a generic fashion, he instead closes the editor and complains on Twitter.</p>
<h2 id="-frequently-asked-questions"><a class="header" href="#-frequently-asked-questions">ðŸ¤” Frequently Asked Questions</a></h2>
<h3 id="what-are-the-morals-of-the-story"><a class="header" href="#what-are-the-morals-of-the-story"><strong>What are the morals of the story?</strong></a></h3>
<ul>
<li>Writing an async <code>Stream</code> is drastically different than writing an <code>async fn</code>.</li>
<li>The documentation for <code>Pin</code> doesn't provide much practical guidance in how to use it, instead focusing on more abstract considerations.</li>
<li>Missing a waker registration is a runtime error, and very hard to debug. If it's even possible, a compiler warning or hint would go a long way.</li>
</ul>
<h3 id="what-are-the-sources-for-this-story"><a class="header" href="#what-are-the-sources-for-this-story"><strong>What are the sources for this story?</strong></a></h3>
<p>Part of this story is based on the original motivation for <code>async</code>/<code>await</code> in Rust, since similar problems exist writing <code>impl Future</code>.</p>
<h3 id="why-did-you-choose-alan-to-tell-this-story"><a class="header" href="#why-did-you-choose-alan-to-tell-this-story"><strong>Why did you choose <a href="../../characters/alan.html">Alan</a> to tell this story?</strong></a></h3>
<p>Choosing Alan was somewhat arbitrary, but this does get to reuse the experience that Alan may already have around <code>await</code> coming from JavaScript.</p>
<h3 id="how-would-this-story-have-played-out-differently-for-the-other-characters"><a class="header" href="#how-would-this-story-have-played-out-differently-for-the-other-characters"><strong>How would this story have played out differently for the other characters?</strong></a></h3>
<ul>
<li>This likely would have been a similar story for any character.</li>
<li>It's possible <a href="../../characters/grace.html">Grace</a> would be more used to writing state machines, coming from C.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../vision/submitted_stories/status_quo/alan_has_an_event_loop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../vision/submitted_stories/status_quo/alan_iteratively_regresses.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../vision/submitted_stories/status_quo/alan_has_an_event_loop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../vision/submitted_stories/status_quo/alan_iteratively_regresses.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
